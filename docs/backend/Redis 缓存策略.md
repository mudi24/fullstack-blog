---
title: Redis 缓存策略 
date: 2025-01-15
readTime: 18 min read
category: 后端
---

### 一、数据过期与淘汰策略（核心缓存管理）

#### 1. **数据过期策略**
Redis 通过以下方式清理过期键值对：
- **惰性删除（Lazy Expire）**  
  访问 Key 时检查是否过期，若过期则删除。  
  **优点**：CPU 友好；**缺点**：内存浪费（过期 Key 未被访问时长期驻留）。
  
- **定期删除（Active Expire）**  
  每隔 100ms 随机抽取部分 Key（默认 20 个）检查，删除过期数据，若发现超过 25% 的 Key 过期则重复此过程。  
  **优点**：平衡内存和 CPU；**缺点**：无法完全实时清理。

#### 2. **内存淘汰策略（8种模式）**
当内存达到 `maxmemory` 限制时触发淘汰，策略通过 `maxmemory-policy` 配置：
- **volatile-lru**：从设置了过期时间的 Key 中淘汰最近最少使用的。
- **allkeys-lru**：从所有 Key 中淘汰 LRU。
- **volatile-lfu** / **allkeys-lfu**：基于使用频率淘汰（Redis 4.0+）。
- **volatile-random** / **allkeys-random**：随机淘汰。
- **volatile-ttl**：淘汰剩余存活时间（TTL）最短的 Key。
- **noeviction**：拒绝写入新数据（默认策略）。

**选型建议**：
- 缓存场景优先选择 `allkeys-lru` 或 `allkeys-lfu`，避免内存溢出。
- 需保留持久化数据时使用 `volatile-*` 策略。

---

### 二、缓存设计模式（与业务逻辑结合）

#### 1. **Cache-Aside（旁路缓存）**
- **读流程**：  
  1. 先查缓存，命中则返回数据。  
  2. 未命中则查数据库，回填缓存后返回数据。  
- **写流程**：  
  1. 更新数据库。  
  2. **删除缓存**（非更新，避免并发写导致脏数据）。  

**优点**：简单易控；**缺点**：存在缓存击穿（Cache Penetration）风险（高并发查空值）。

#### 2. **Read-Through/Write-Through（读写穿透）**
- **代理层封装**：缓存作为数据库代理，应用直接读写缓存，由缓存同步数据到数据库。  
- **适用场景**：需要强一致性的场景，但缓存层复杂度高（如使用 Redis + 自定义逻辑）。

#### 3. **Write-Behind（异步回写）**
- **写流程**：先更新缓存，异步批量回写数据库。  
- **优点**：极高写入性能；**缺点**：数据丢失风险（缓存宕机）。

---

### 三、缓存问题防御策略

#### 1. **缓存穿透（查询不存在的数据）**
- **布隆过滤器（Bloom Filter）**  
  在 Redis 前加一层布隆过滤器（如 RedisBloom 模块），拦截非法 Key 查询。  
  ```redis
  BF.ADD myfilter "user:123"  # 添加 Key 到过滤器
  BF.EXISTS myfilter "user:456"  # 检查是否存在
  ```
- **空值缓存**：查询数据库为空时，缓存空值并设置短过期时间。

#### 2. **缓存雪崩（大量 Key 同时过期）**
- **随机化过期时间**：在基础 TTL 上添加随机值（如 `TTL + random(0, 300)`）。  
- **热点数据永不过期**：结合后台定时任务异步更新缓存。

#### 3. **缓存击穿（热点 Key 过期后瞬间高并发）**
- **互斥锁（Mutex Lock）**：使用分布式锁，仅允许一个线程回源数据库。  
- **逻辑过期**：缓存 Value 中存储实际过期时间，由异步线程检测更新。

---

### 四、高级数据结构应用策略

#### 1. **HyperLogLog（基数统计）**
- 用于 UV（独立访客）统计，误差率约 0.81%。  
  ```redis
  PFADD uv:20231001 "user1" "user2"  
  PFCOUNT uv:20231001  
  ```
- **节省内存**：1亿 UV 仅需 12KB。

#### 2. **Bitmaps（位图操作）**
- 记录用户签到、布尔型标记：  
  ```redis
  SETBIT sign:user:202310 1 1  # 第1天签到
  BITCOUNT sign:user:202310     # 统计当月签到次数
  ```

#### 3. **GEO（地理位置）**
- 存储坐标并计算距离：  
  ```redis
  GEOADD cities 116.405285 39.904989 "Beijing"  
  GEODIST cities "Beijing" "Shanghai" km  
  ```

---

### 五、持久化与缓存一致性策略

#### 1. **RDB（快照）**
- 定时生成数据快照（二进制文件），适合冷备。  
- **配置**：`save 900 1`（900秒内至少1次修改触发保存）。

#### 2. **AOF（追加日志）**
- 记录所有写操作命令（可配置为每秒同步或每次操作同步）。  
- **混合持久化**（Redis 4.0+）：AOF 文件包含 RDB 头 + 增量 AOF 日志，兼顾恢复速度和数据安全。

#### 3. **缓存与数据库一致性**
- **最终一致性**：接受短暂不一致，通过失效机制或订阅数据库 Binlog 同步（如 Canal + MQ）。  
- **强一致性**：需结合分布式事务（如 Redisson 的 `RTransaction`），但性能损耗大。

---

### 六、集群与分片策略

#### 1. **Redis Cluster（官方分片方案）**
- 数据分片到 16384 个槽（Slot），每个节点负责部分槽。  
- **客户端路由**：通过 CRC16(key) % 16384 计算槽位置，直连对应节点。  
- **优点**：自动数据迁移、高可用；**缺点**：不支持跨槽事务。

#### 2. **Codis/Proxy 分片**
- 通过代理层（如 Codis）实现分片，对客户端透明。  
- **适用场景**：需兼容旧客户端或跨数据中心同步。

---

### 七、性能优化策略

#### 1. **Pipeline（管道批处理）**
- 减少网络往返（RTT），提升批量操作吞吐量：  
  ```python
  pipeline = redis.pipeline()
  pipeline.set("key1", "value1")
  pipeline.get("key2")
  results = pipeline.execute()
  ```

#### 2. **连接池配置**
- 避免频繁创建连接，合理设置 `max_idle` 和 `max_total`（如 Java 的 JedisPool）。  
- **监控指标**：连接数、等待时间、活跃连接。

#### 3. **内存优化**
- 使用 `ziplist` 编码小规模数据：  
  ```redis
  hash-max-ziplist-entries 512  # Hash 元素数小于512时用 ziplist
  list-max-ziplist-size 64       # List 元素大小小于64字节用 ziplist
  ```

---

### 八、总结与选型矩阵

| 策略类型         | 典型场景                     | 技术选型建议                              |
|------------------|----------------------------|------------------------------------------|
| **数据淘汰**     | 内存不足时清理数据           | `allkeys-lru`（缓存场景） / `volatile-ttl`（混合数据） |
| **缓存模式**     | 高并发读写                  | Cache-Aside（通用） + Bloom Filter（防穿透） |
| **持久化**       | 宕机恢复                    | RDB（快照备份） + AOF（增量日志）               |
| **集群扩展**     | 大数据量高可用              | Redis Cluster（官方方案） / Codis（代理分片）   |

**最佳实践**：
- 监控 `内存使用率`、`命中率`、`延迟` 等核心指标。
- 结合 `多级缓存`（如本地缓存 Caffeine + Redis）减少穿透压力。
- 使用 `Lua 脚本` 保证复杂操作原子性，替代事务。